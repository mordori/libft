/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_math.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: myli-pen <myli-pen@student.hive.fi>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/03 01:14:46 by myli-pen          #+#    #+#             */
/*   Updated: 2025/07/16 23:20:38 by myli-pen         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft_math.h"
#include "libft_mem.h"

/**
 * Calculates a fast approximation of the square root of a number.
 *
 * This method originates from QUAKE III inverse square root algorithm.
 * It uses two Newton-Raphson iterations to refine an initial guess,
 * yielding approximately 5 to 6 decimal digits of precision.
 *
 * The initial guess is generated by interpreting the bits of the input float
 * as a 32-bit integer, then performing a bit-level manipulation:
 * the exponent part of the floating-point number is roughly halved by
 * shifting bits to the right by one, and subtracting the result from the
 * magic constant 0x5f3759df. This produces an approximation for the inverse
 * square root (1/sqrt(n)). Multiplying this inverse square root by `n`
 * yields an approximation of sqrt(n).
 *
 * @param n Number inputted.
 * @return Approximation of the square root of the number.
 * @deprecated Modern hardware is faster and more precise at calculating sqrt.
 * Made this to better understand how floats operate bitwise.
 */
float	fast_sqrt(float n)
{
	float		x;
	float		xhalf;
	uint32_t	i;

	if (n < 0.0f)
		return (NAN);
	if (n == 0.0f)
		return (0.0f);
	x = n;
	xhalf = 0.5f * x;
	ft_memcpy(&i, &x, sizeof (i));
	i = 0x5f3759df - (i >> 1);
	ft_memcpy(&x, &i, sizeof (x));
	x = x * (1.5f - xhalf * x * x);
	x = x * (1.5f - xhalf * x * x);
	return (n * x);
}

float	ft_fmax(float a, float b)
{
	if (a > b)
		return (a);
	return (b);
}

float	ft_fmin(float a, float b)
{
	if (a < b)
		return (a);
	return (b);
}
